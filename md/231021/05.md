# swift의 타입 안정성을 보장하는 방법

스위프트는 타입안정성 `type safety` 에 매우 중점을 둔 프로그래밍 언어이다.
타입 안정성: 코드에서 의도하지 않은 타입의 값을 사용하거나, 잘못된 방식으로 데이터를 다루는 실수를 방지하는 프로그래밍 언어의 특성이다.

## 강력한 타입 시스템

스위프트는 변수나 상수를 선언할 때 그 타입을 명확히 지정하게 설계되었다.
그래서 컴파일러는 해당 타입 외의 값을 할당하려고 시도할 때 오류를 발생한다.

```swift
var name: String = ''
name = 123 // Error
```

## 타입 추론 `Type Interence`

스위프트의 컴파일러는 변수나 상수의 초기 값을 바탕으로 그 타입을 추론할 수 있다.
이로 인해 명시적으로 타입을 지정하지 않아도 컴파일러가 적절한 타입을 추론하고 오류를 방지한다.

```swift
let age = 30 // Int 타입으로 추론함
```

## 옵셔널 `Optional`

스위프트에서 값이 있을수도, 없을수도 있는 상황을 표기하기 위해 옵셔널이라는 개념을 도입했다.
옵셔널을 사용하면 값의 부재를 안전하게 처리하고, `nil` 값의 실수를 방지할 수 있다.

## as 키워드를 통한 타입캐스팅

다른 타입으로 캐스팅할 때 사용된다.

1. `as?` 
    - 조건부 캐스팅 수행한다.
    - 만약 캐스팅이 가능하다면, 캐스팅된 값을 옵셔널 형태로 반환하고, 캐스팅이 불가능하면 nil을 반환한다.

2. `as!`
    - 강제 캐스팅을 수행한다.
    - 만약 캐스팅이 가능하다면 캐스팅된 값을 반환하며, 캐스팅이 불가능하다면 런타임오류를 발생하기 때문에 주의가 필요하다.

```swift
if let stringName = name as? String {
    print("name변수는 String타입이었고, 캐스팅 결과로 stringName 변수가 생겼다.")
}
print("name변수가 nil일땐 if 블록내부는 실행되지 않는다.")

let forcedStringValue: String = anyValue as! String
print(forcedStringValue)
```

> #### 코드분석
> 
> `as? String`
    - name 변수를 String 타입으로 조건부를 통해 안전하게 캐스팅하려고 시도한다.
    - 만약 name이 실제로 String 타입이라면 캐스팅이 성공하고, 그렇지 않으면 캐스팅은 실패하고 nil을 반환한다.
`if let stringNAme = ...`
    - 조건부 바인딩이다.
    - 캐스팅의 결과가 nil이 아니라면 (= 캐스팅이 성공했다면) 그 값을 stringName 상수에 할당하고, if 블록 내부의 코드를 실행한다.
    - 만약 캐스팅이 실패하거나 결과가 nil이라면 if 블록 내부의 코드는 실행되지 않는다.    


## is 키워드를 통한 타입확인

- 런타임에서 객체가 특정 타입인지 확인할 때 사용된다.
- 타입을 확인만 할 뿐, 실제로 값을 해당 타입으로 변환하지는 않는다.
- 값의 타입 확인을 위해 주로 조건문 내부에서 사용된다.

```swift
let value: Any = "Hello Swift!"

if value is String {
    print("value는 String타입입니다.")
}
if value is Int {
    print("value는 Int 타입입니다.")
} else {
    print("value는 Int타입이 아닙니다.")
}
```

## 배열과 딕셔너리의 제네릭 타입

스위프트의 컬렉션 타입들을 제네릭을 사용하면 안전하게 타입을 지정한다.
그래서 잘못된 타입의 값을 추가하려고 시도할 때 컴파일러가 오류를 발생시킨다.

```swift
var nums: [Int] = [1,2,3]
nums.append("") // Error
```

## 프로토콜 지향 프로그래밍

프로토콜을 사용해서 객체의 특정 행동과 속성을 명확하게 정의할 수 있으며, 이를 통해 적절한 타입의 객체만 사용되도록 보장한다.

